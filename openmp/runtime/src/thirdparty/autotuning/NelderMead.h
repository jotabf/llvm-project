
/// @file NelderMead.hpp
/// @brief Declaration of the NelderMead class for numerical optimization using
/// the Nelder-Mead algorithm.

#pragma once

#include <cstdlib> // drand48_data

#include "NumericalOptimizer.h"

/// @class NelderMead
/// @brief Implementation of the Nelder-Mead algorithm for numerical
/// optimization.
class NelderMead {
  inline static const double MIN_ERROR_TO_INT = 0.0222222;

  enum { NO_SAVE = -1 }; ///< Flag indicating that the cost should not be saved

  enum steps {
    init,                     ///< Initialization step
    reflection,               ///< Reflection step
    decision,                 ///< Decision step
    decision_reflection,      ///< Decision to reflect
    decision_expansion,       ///< Decision to expand
    decision_out_contraction, ///< Decision to contract out
    decision_in_contraction,  ///< Decision to contract in
    expansion,                ///< Expansion step
    out_contraction,          ///< Outer contraction step
    in_contraction,           ///< Inner contraction step
    reduction,                ///< Reduction step
    finalization              ///< Finalization step
  };

  // Algorithm parameters
  static const double m_alpha; ///< Used in reflection
  static const double m_gamma; ///< Used in expansion
  static const double m_rho;   ///< Used in contraction
  static const double m_sigma; ///< Used in reduction

  // Problem-specific parameters
  unsigned m_dim;     ///< Dimensionality of the problem
  unsigned m_nPoints; ///< Number of solutions in the algorithm
  double m_error;     ///< Error threshold for terminating the algorithm

  // Variables for algorithm state
  unsigned m_bestID;   ///< Index of the best solution
  unsigned m_worstID;  ///< Index of the worst solution
  unsigned m_secondID; ///< Index of the second worst solution
  unsigned m_step;     ///< Current step in the algorithm
  unsigned m_iPoint;   ///< Index of the current point
#ifdef AT_DEBUG
  unsigned m_iIteration;  ///< Number of iterations
  unsigned m_iEvaluation; ///< Number of evaluations
#endif
  long m_iCost; ///< Index of the point to save

  // Cost variables for different points
  double m_costReflection;  ///< Cost of reflected point
  double m_costExpansion;   ///< Cost of expanded point
  double m_costContraction; ///< Cost of contracted point

  // Arrays to store points, costs, and centroid
  double **p_points;  ///< Vector where each line will be a solution
                      ///< 'dim'-dimensional
  double *p_costs;    ///< Costs associated with each solution
  double *p_centroid; ///< Centroid of the solutions

  // Points generated by different steps
  double *p_pointReflection;  ///< Point generated by reflection
  double *p_pointExpansion;   ///< Point generated by expansion
  double *p_pointContraction; ///< Point generated by contraction

  struct drand48_data buffer; ///< To use in random seed

  // Private member functions
  int make_decision(double _cost) const; ///< Make a decision based on the cost
  void set_points();         ///< Set initial points for the algorithm
  void sort_points();        ///< Sort solutions based on their costs
  void calculate_centroid(); ///< Calculate the centroid of the solutions
  /// p_out = p_in2 + _const/// (p_in1 - p_in2)
  void calculate_point(double *&p_out, double _const, double *p_in1,
                       double *p_in2);
  double volume(); ///< Calculate the volume of the solutions
  // static void swap(double *&p1, double *&p2); ///< Swap two pointers
  // static void swap(double &p1, double &p2); ///< Swap two values

public:
  /// @brief Get the number of points used in the algorithm.
  /// @return Number of points.
  unsigned getNumPoints() const { return m_nPoints; };

  /// @brief Get the dimensionality of the problem.
  /// @return Dimensionality.
  unsigned getDimension() const { return m_dim; };

  /// @brief Reset the state of the algorithm.
  /// @param level Reset level, indicating how to reset the algorithm.
  /// - Level 0: Reset but keep best point (default)
  /// - Level 1: Reset all points
  void reset(unsigned level = 0);

  /// @brief Check if the optimization has reached the end.
  /// @return True if the optimization has ended, false otherwise.
  bool isEnd() const { return m_step == steps::finalization; }

  /// @brief Run one iteration of the Nelder-Mead algorithm.
  /// @param _cost The cost associated with the current solution.
  /// @return Pointer to the next solution.
  double *run(double _cost);

  static NelderMead *Create(unsigned dim, double error = MIN_ERROR_TO_INT);

  static void Destroy(NelderMead *optimizer) { free(optimizer); }

  // Deleted functions to prevent unwanted behavior
  NelderMead() = delete;
  NelderMead(const NelderMead &) = delete;
  NelderMead(NelderMead &&) = delete;
  NelderMead operator=(NelderMead) = delete;
  NelderMead &operator=(NelderMead &&) = delete;
  ~NelderMead() = delete;
};