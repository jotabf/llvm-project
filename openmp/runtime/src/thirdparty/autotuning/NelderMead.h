
/// @file NelderMead.hpp
/// @brief Declaration of the NelderMead class for numerical optimization using
/// the Nelder-Mead algorithm.

#pragma once

#include <cstdlib> // drand48_data

#include "NumericalOptimizer.h"

/// @class NelderMead
/// @brief Implementation of the Nelder-Mead algorithm for numerical
/// optimization.
class NelderMead : public NumericalOptimizer {
  enum { no_save = -1 }; ///< Flag indicating that the cost should not be saved

  enum steps {
    init, ///< Initialization step
    reflection, ///< Reflection step
    decision, ///< Decision step
    decision_reflection, ///< Decision to reflect
    decision_expansion, ///< Decision to expand
    decision_out_contraction, ///< Decision to contract out
    decision_in_contraction, ///< Decision to contract in
    expansion, ///< Expansion step
    out_contraction, ///< Outer contraction step
    in_contraction, ///< Inner contraction step
    reduction, ///< Reduction step
    finalization = NOPT_FINALIZATION
  };

  // Algorithm parameters
  static const double m_alpha; ///< Used in reflection
  static const double m_gamma; ///< Used in expansion
  static const double m_rho; ///< Used in contraction
  static const double m_sigma; ///< Used in reduction

  // Problem-specific parameters
  const unsigned m_dim; ///< Dimensionality of the problem
  const unsigned m_nPoints; ///< Number of solutions in the algorithm
  const double m_error; ///< Error threshold for terminating the algorithm

  // Variables for algorithm state
  const unsigned m_bestID; ///< Index of the best solution
  const unsigned m_worstID; ///< Index of the worst solution
  const unsigned m_secondID; ///< Index of the second worst solution
  unsigned m_step; ///< Current step in the algorithm
  unsigned m_iPoint; ///< Index of the current point
#ifdef AT_DEBUG
  unsigned m_iIteration; ///< Number of iterations
  unsigned m_iEvaluation; ///< Number of evaluations
#endif
  long m_iCost; ///< Index of the point to save

  // Cost variables for different points
  double m_costReflection; ///< Cost of reflected point
  double m_costExpansion; ///< Cost of expanded point
  double m_costContraction; ///< Cost of contracted point

  // Points generated by different steps
  // double *p_pointReflection; ///< Point generated by reflection
  // double *p_pointExpansion; ///< Point generated by expansion
  // double *p_pointContraction; ///< Point generated by contraction
  std::vector<double> p_pointReflection;
  std::vector<double> p_pointExpansion;
  std::vector<double> p_pointContraction;

  // Arrays to store points, costs, and centroid
  // double **p_points; ///< Vector where each line will be a solution
  //                    ///< 'dim'-dimensional
  // double *const p_costs; ///< Costs associated with each solution
  // double *const p_centroid; ///< Centroid of the solutions
  // double *const p_bestPoint; ///< Best solution found
  std::vector<std::vector<double>> p_points;
  std::vector<double> p_costs;
  std::vector<double> p_centroid;
  // std::vector<double> p_bestPoint;

  double m_result; ///< Temporary double variables
  struct drand48_data buffer; ///< To use in random seed

  // Private member functions
  int make_decision(double _cost) const; ///< Make a decision based on the cost
  void set_points(); ///< Set initial points for the algorithm
  void sort_points(); ///< Sort solutions based on their costs
  void calculate_centroid(); ///< Calculate the centroid of the solutions
  /// p_out = p_in2 + _const/// (p_in1 - p_in2)
  // void calculate_point(double *&p_out, double _const, double *p_in1,
  //                      double *p_in2);
  void calculate_point(std::vector<double> &p_out, double _const,
                       const std::vector<double> &p_in1,
                       const std::vector<double> &p_in2);
  double volume(); ///< Calculate the volume of the solutions
  // static void swap(double *&p1, double *&p2); ///< Swap two pointers
  // static void swap(double &p1, double &p2); ///< Swap two values

public:
  /// @brief Get the number of points used in the algorithm.
  /// @return Number of points.
  unsigned getNumPoints() const override { return m_nPoints; };

  /// @brief Get the dimensionality of the problem.
  /// @return Dimensionality.
  unsigned getDimension() const override { return m_dim; };

  /// @brief Reset the state of the algorithm.
  /// @param level Reset level, indicating how to reset the algorithm.
  /// - Level 0: Reset but keep best point (default)
  /// - Level 1: Reset all points
  void reset(unsigned level = 0) override;

  /// @brief Check if the optimization has reached the end.
  /// @return True if the optimization has ended, false otherwise.
  bool isEnd() const override { return m_step == steps::finalization; }

  /// @brief Run one iteration of the Nelder-Mead algorithm.
  /// @param _cost The cost associated with the current solution.
  /// @return Pointer to the next solution.
  std::vector<double> run(double _cost) override;

  /// @brief Constructor for the NelderMead class.
  /// @param dim Dimensionality of the problem.
  /// @param error Error threshold for terminating the algorithm.
  NelderMead(unsigned dim, double error);

  /// @brief Destructor for the NelderMead class.
  ~NelderMead() override;

  // Deleted functions to prevent unwanted behavior
  NelderMead() = delete;
  NelderMead(const NelderMead &) = delete;
  NelderMead(NelderMead &&) = delete;
  NelderMead operator=(NelderMead) = delete;
  NelderMead &operator=(NelderMead &&) = delete;

  /// @brief Get the information about the Nelder-Mead algorithm.
  /// @return Information about the algorithm.
  std::string getInfo() const override;

#ifdef AT_DEBUG
  /// @brief Get the debug information about the Nelder-Mead algorithm.
  /// Similar to getInfo, but the information only exists in debug mode.
  /// @return Debug information about the algorithm.
  std::string getDebugInfo() const override;
#endif
};