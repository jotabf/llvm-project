
/// @file NelderMead.hpp
/// @brief Declaration of the NelderMead class for numerical optimization using
/// the Nelder-Mead algorithm.

#pragma once

#include <random>

#include "NumericalOptimizer.h"

/// @class NelderMead
/// @brief Implementation of the Nelder-Mead algorithm for numerical
/// optimization.
class NelderMead {
  enum { NO_SAVE = -1 }; ///< Flag indicating that the cost should not be saved

  enum steps {
    init,                     ///< Initialization step
    reflection,               ///< Reflection step
    decision,                 ///< Decision step
    decision_reflection,      ///< Decision to reflect
    decision_expansion,       ///< Decision to expand
    decision_out_contraction, ///< Decision to contract out
    decision_in_contraction,  ///< Decision to contract in
    expansion,                ///< Expansion step
    out_contraction,          ///< Outer contraction step
    in_contraction,           ///< Inner contraction step
    reduction,                ///< Reduction step
    finalization              ///< Finalization step
  };

  // Algorithm parameters
  static const double m_alpha; ///< Used in reflection
  static const double m_gamma; ///< Used in expansion
  static const double m_rho;   ///< Used in contraction
  static const double m_sigma; ///< Used in reduction

  // Problem-specific parameters
  unsigned m_dim;     ///< Dimensionality of the problem
  unsigned m_nPoints; ///< Number of solutions in the algorithm
  int64_t m_error;    ///< Error threshold for terminating the algorithm

  // Variables for algorithm state
  inline static const unsigned m_bestID = 0; ///< Index of the best solution
  unsigned m_worstID;                        ///< Index of the worst solution
  unsigned m_secondID; ///< Index of the second worst solution
  unsigned m_step;     ///< Current step in the algorithm
  unsigned m_iPoint;   ///< Index of the current point
  long m_iCost;        ///< Index of the point to save

  // Cost variables for different points
  double m_costReflection;  ///< Cost of reflected point
  double m_costExpansion;   ///< Cost of expanded point
  double m_costContraction; ///< Cost of contracted point

  int64_t m_min;
  int64_t m_max;

  // Arrays to store points, costs, and centroid
  double *p_costs;     ///< Costs associated with each solution
  int64_t **p_points;  ///< Vector where each line will be a solution
                       ///< 'dim'-dimensional
  int64_t *p_centroid; ///< Centroid of the solutions

  // Points generated by different steps
  int64_t *p_pointReflection;  ///< Point generated by reflection
  int64_t *p_pointExpansion;   ///< Point generated by expansion
  int64_t *p_pointContraction; ///< Point generated by contraction

  int64_t circ_mod(int64_t x) const;
  int64_t rand_gen();

  // Private member functions
  int make_decision(double _cost) const; ///< Make a decision based on the cost
  void sort_points();        ///< Sort solutions based on their costs
  void calculate_centroid(); ///< Calculate the centroid of the solutions
  void
  calculate_point(int64_t *&p_out, double _const, int64_t *p_in1,
                  int64_t *p_in2); /// p_out = p_in2 + _const * (p_in1 - p_in2)
  double volume() const;           ///< Calculate the volume of the solutions

public:
  /// @brief Get the number of points used in the algorithm.
  /// @return Number of points.
  unsigned getNumPoints() const { return m_nPoints; };

  /// @brief Get the dimensionality of the problem.
  /// @return Dimensionality.
  unsigned getDim() const { return m_dim; };

  int64_t getMin() const { return m_min; }

  int64_t getMax() const { return m_max; }

  void setLimits(int64_t min, int64_t max) {
    m_min = min;
    m_max = max;
  }

  void setError(int64_t error) { m_error = error; }

  /// @brief Reset the state of the algorithm.
  /// @param level Reset level, indicating how to reset the algorithm.
  /// - Level 0: Reset but keep best point (default)
  /// - Level 1: Reset all points
  void reset(unsigned level = 0);

  /// @brief Check if the optimization has reached the end.
  /// @return True if the optimization has ended, false otherwise.
  bool isEnd() const { return m_step == steps::finalization; }

  /// @brief Run one iteration of the Nelder-Mead algorithm.
  /// @param _cost The cost associated with the current solution.
  /// @return Pointer to the next solution.
  int64_t *run(double _cost);

  static NelderMead *Create(int64_t min, int64_t max, unsigned dim,
                            int64_t error);

  static void Destroy(NelderMead *optimizer);

  // Deleted functions to prevent unwanted behavior
  NelderMead() = delete;
  NelderMead(const NelderMead &) = delete;
  NelderMead(NelderMead &&) = delete;
  NelderMead operator=(NelderMead) = delete;
  NelderMead &operator=(NelderMead &&) = delete;
  ~NelderMead() = delete;
};